#ifndef _LIBDISPATCH_CORE_
#define _LIBDISPATCH_CORE_

#ifndef _LIBDISPATCH_PUBLIC_
#error "Please #include <dispatch/dispatch.h> instead of this file directly."
#endif

/*!
 * @header
 *
 * Libdispatch is an abstract model for expressing concurrency via the 
 * asynchronous invocation of Blocks.
 *
 * At its core, libdispatch provides serial FIFO queues to which Blocks may be
 * submitted.  Blocks submitted to these dispatch queues are invoked on a pool
 * of threads fully managed by the system.  No guarantee is made regarding which
 * thread a Block will be invoked on; however, it is guaranteed that only one
 * Block submitted to the FIFO dispatch queue will be invoked at a time.
 *
 * When multiple queues have Blocks to be processed, the system is free to
 * allocate additional threads to invoke the Blocks concurrently.  When
 * the queues become empty, these threads are automatically released.
 *
 * A main queue is automatically created by the system and associated
 * with the main thread.  In order to invoke Blocks submitted to the main
 * queue, the application must call dispatch_main(), NSApplicationMain(),
 * or use a CFRunLoop on the main thread.
 *
 * Completion callbacks:
 *
 * Completion callbacks for Blocks submitted to queues may be trivially
 * implemented by nesting a call to dispatch_async() targeting the original
 * queue within the Block.  It is important to remember to retain the original
 * queue (e.g. the current queue) before the first call to dispatch_async(), and
 * to release that queue at the end of the completion callback.
 *
 * The system holds a reference on a dispatch queue for the duration of a
 * Block's execution, allowing the following:
 *
 *     dispatch_queue_t current = dispatch_get_current_queue();
 *
 *     dispatch_queue_retain(current);
 *     dispatch_async(another_queue, ^{
 *         // asynchronous operation
 *         void* data;
 *         int res = do_something(&data);
 *
 *         // completion callback
 *         dispatch_async(current, ^{
 *             something_finished(res, data);
 *             dispatch_queue_release(current);
 *         });
 *     });
 *
 *
 * Note on Objective-C and C++ compatibility:
 *
 * Libdispatch is a C level API.
 * Libdispatch does not catch exceptions generated by higher level languages.
 * Applications MUST catch all exceptions before returning from a Block
 * submitted to a dispatch queue.
 *
 * Note on POSIX threads compatibility:
 *
 * Libdispatch manages the relationship between dispatch queues and threads.
 *
 * Applications MUST NOT delete or mutate objects that they did not create.
 * Therefore, the following APIs MUST NOT be called by Blocks submitted to
 * a dispatch queue:
 *
 * pthread_cancel()
 * pthread_detach()
 * pthread_join()
 * pthread_kill()
 * pthread_exit()
 *
 * Applications MAY call the following APIs if-and-only-if they restore the
 * thread back to its original state before returning from Blocks submitted
 * to a dispach queue:
 *
 * pthread_setcancelstate()
 * pthread_setcanceltype()
 * pthread_setschedparam()
 * pthread_sigmask()
 * pthread_setugid_np()
 * pthread_chdir()
 * pthread_fchdir()
 *
 * Applications MUST NOT rely on the following APIs returning predictable
 * results between invocations of Blocks submitted to a dispatch queue:
 *
 * pthread_self()
 * pthread_getschedparam()
 * pthread_get_stacksize_np()
 * pthread_get_stackaddr_np()
 * pthread_mach_thread_np()
 * pthread_from_mach_thread_np()
 *
 * The result of pthread_self() can change between invocations of Blocks,
 * but the value will not change during the lifetime of any given Block.
 * Please be cognizant of that fact when using
 * pthread_setspecific() and pthread_getspecific(). In particular, using
 * per-thread data as an out-of-band return value is error prone.  One also
 * cannot make any assumptions about "when" the destructor passed to
 * pthread_key_create() is called.  Libdispatch only promises that it will get
 * called. Libdispatch may do so between calls to Blocks, or during the
 * "idle" state of a process.
 *
 * The following example code CORRECTLY handles per-thread return values:
 *
 * __block int r;
 * __block int e;
 * dispatch_sync(q, ^{
 *     r = kill(1, 0);
 *     e = errno; // Copy the per-thread return value to the callee's thread
 * });
 * printf("kill(1, 0) returned %d and errno == %d\n", r, e);
 * 
 * Please note in the above that 'errno' is a per-thread variable, and must be
 * copied out explicitly, since the Block may be invoked on another thread.
 * Another example would be the use of getpwnam() instead of getpwnam_r(),
 * since the former returns per-thread data.
 * 
 * As an optimization, dispatch_sync() invokes the Block on the current
 * thread when possible.  In this case, thread-specific data such as 'errno'
 * may persist from the Block until after dispatch_sync() returns.  Great
 * care should be taken not to accidentally rely on these side-effects.
 *
 * Any future or overlooked POSIX threading API that deletes or otherwise
 * modifies the life cycle of a pthread_t object will be added to these lists.
 */

/*!
 * @typedef	dispatch_queue_t
 *
 * @abstract
 * Dispatch queues invoke Blocks submitted to them serially in FIFO order.
 * A queue will only invoke one Block at a time, but independent queues
 * may each invoke their Blocks concurrently with respect to each other.
 *
 * @discussion
 * Dispatch queues are lightweight objects to which Blocks may be
 * submitted.  The system manages a pool of threads which process
 * dispatch queues and invoke Blocks submitted to them.
 *
 * Conceptually any dispatch queue may have its own thread of execution,
 * and interaction between queues is highly asynchronous.
 *
 * Dispatch queues are reference counted via calls to dipatch_queue_retain()
 * and dispatch_queue_release().  Pending Blocks submitted to a queue also
 * hold a reference to the queue until they have finished.  Once all
 * references to a queue have been released, the queue will be deallocated
 * by the system.
 */
typedef struct dispatch_queue_s *dispatch_queue_t;

/*!
 * @typedef	dispatch_queue_attr_t
 *
 * @abstract
 * Attribute and policy extensions for dispatch queues.
 */
typedef struct dispatch_queue_attr_s *dispatch_queue_attr_t;


/*!
 * @typedef     dispatch_block_t
 *
 * @abstract
 * The prototype of Blocks submitted to dispatch queues, which take no
 * arguments and have no return value.
 *
 * @discussion
 * The declaration of a Block allocates storage on the stack.  Therefore, this
 * is an invalid construct:
 *
 * dispatch_block_t block;
 *
 * if (x) {
 *     block = ^{ printf("true\n"); };
 * } else {
 *     block = ^{ printf("false\n"); };
 * }
 * block(); // unsafe!!!
 *
 * What is happening behind the scenes:
 *
 * if (x) {
 *     struct Block __tmp_1 = ...; // setup details
 *     block = &__tmp_1;
 * } else {
 *     struct Block __tmp_2 = ...; // setup details
 *     block = &__tmp_2;
 * }
 *
 * As the example demonstrates, the address of a stack variable is escaping the
 * scope in which it is allocated. That is a classic C bug.
 */
typedef void (^dispatch_block_t)(void);

/*!
 * @function	dispatch_async
 *
 * @abstract
 * Submits a Block for asynchronous execution on a dispatch queue.
 *
 * @discussion
 * The dispatch_async() function is the fundamental mechanism for submitting
 * Blocks to a dispatch queue.
 *
 * Calls to dispatch_async() always return immediately after the Block has
 * been submitted, and never wait for the Block to be invoked.
 *
 * The target queue determines whether the Block will be invoked serially or
 * concurrently with respect to other Blocks submitted to that same queue.
 * Serial queues are processed concurrently with with respect to each other.
 * 
 * @param	queue
 * The target dispatch queue to which the Block is submitted.
 * The system will hold a reference on the target queue until the Block
 * has finished.
 *
 * @param	block
 * The Block to submit to the target dispatch queue.
 *
 * The system will perform a Block_copy() on the application's behalf,
 * and a Block_release() after the Block has finished. 
 *
 * @result
 * Non-zero on failure. Zero on success.
 */

__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_NA)
DISPATCH_PUBLIC_API DISPATCH_NONNULL_ALL
long
dispatch_async(dispatch_queue_t queue, dispatch_block_t block);

/*!
 * @function	dispatch_sync
 *
 * @abstract
 * Submits a Block for synchronous execution on a dispatch queue.
 *
 * @discussion
 * Submits a Block to a dispatch queue like dispatch_async(), however
 * dispatch_sync() will not return until the Block has finished.
 *
 * Calls to dispatch_sync() targeting the current queue will result
 * in dead-lock.  Use of dispatch_sync() is also subject to the same
 * multi-party dead-lock problems that may result from the use of a mutex.
 * Use of dispatch_async() is preferred.
 *
 * As an optimization, dispatch_sync() invokes the Block on the current
 * thread when possible.
 *
 * @param	queue
 * The target dispatch queue to which the Block is submitted.
 *
 * @param	block
 * The Block to be invoked on the target dispatch queue.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_NA)
DISPATCH_PUBLIC_API DISPATCH_NONNULL_ALL
void
dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);

/*!
 * @function	dispatch_apply
 *
 * @abstract
 * Submits a Block to a dispatch queue for multiple invocations.
 *
 * @discussion
 * Submits a Block to a dispatch queue for multiple invocations.  This function
 * waits for the task block to complete before returning.  If the target queue
 * is a concurrent queue returned by dispatch_get_concurrent_queue(), the Block
 * may be invoked concurrently, and it must therefore be reentrant safe.
 * 
 * Each invocation of the Block will be passed the current index of iteration.
 *
 * @param	queue
 * The target dispatch queue to which the Block is submitted.
 *
 * @param	iterations
 * The number of iterations to perform.
 *
 * @param	block
 * The Block to be invoked the specified number of iterations.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_NA)
DISPATCH_PUBLIC_API DISPATCH_NONNULL_ALL
void
dispatch_apply(dispatch_queue_t queue, size_t iterations, void (^block)(size_t));

/*!
 * @function	dispatch_get_current_queue
 *
 * @abstract
 * Returns the queue to which the currently executing Block was submitted.
 * 
 * @discussion
 * Returns the queue to which the currently executing Block was submitted.
 *
 * When dispatch_get_current_queue() is called outside of the context of a
 * submitted Block, the behavior is as follows:
 *  - If called from the main thread, the main queue is returned.
 *  - If called from a CFRunLoop/NSRunLoop callout, the dispatch queue
 *    associated with that run loop is returned.
 *  - Finally, if the thread is not the main thread and does not have an
 *     associated CFRunLoop/NSRunLoop, then NULL is returned.
 *
 * @result
 * Returns the current queue.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_NA)
DISPATCH_PUBLIC_API DISPATCH_PURE DISPATCH_WARN_RESULT
dispatch_queue_t
dispatch_get_current_queue(void);

/*!
 * @function	dispatch_get_main_queue
 *
 * @result
 * Returns the main queue (associated with the main thread).  This queue is
 * created automatically on behalf of main() before main() is called.
 *
 * Blocks submitted to this queue will not be invoked until a call to
 * dispatch_main() is made, or unless a CFRunLoop is used on the main thread.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_NA)
DISPATCH_PUBLIC_API DISPATCH_PURE DISPATCH_WARN_RESULT
dispatch_queue_t
dispatch_get_main_queue(void);

/*!
 * @function	dispatch_get_concurrent_queue
 *
 * @abstract
 * Returns a well-known global concurrent queue of a given priority level.
 *
 * @discussion
 * Blocks submitted to the returned queue may be invoked concurrently with
 * respect to each other.
 *
 * These queues are useful for performing one-shot asynchronous operations,
 * e.g. dispatch_async() to an "anonymous" queue; or for performing parallel
 * loops concurrently on multiple processors, e.g. dispatch_apply().
 *
 * The dispatch queues returned by this function are managed by the system for
 * the lifetime of the application, and need not be retained or released
 * directly by the application.  Furthermore, dispatch_queue_suspend() and
 * dispatch_queue_resume() are not supported on these global queues, and will
 * be ignored.
 *
 * @param	priority
 * The requested priority level for the queue (default is zero):
 * - DISPATCH_QUEUE_PRIORITY_HIGH
 * - DISPATCH_QUEUE_PRIORITY_DEFAULT
 * - DISPATCH_QUEUE_PRIORITY_LOW
 *
 * @result
 * Returns a concurrent dispatch queue for use with dispatch_async(),
 * dispatch_apply(), et al.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_NA)
DISPATCH_PUBLIC_API DISPATCH_PURE DISPATCH_WARN_RESULT
dispatch_queue_t
dispatch_get_concurrent_queue(long priority);


/*!
 * @function	dispatch_queue_create
 *
 * @abstract
 * Creates a new dispatch queue to which Blocks may be submitted.
 *
 * @discussion
 * Dispatch queues invoke Blocks serially in FIFO order.
 *
 * When the dispatch queue is no longer needed, it should be released
 * with dispatch_queue_release().  Note that any pending Blocks submitted
 * to a queue will hold a reference to that queue.  Therefore a queue
 * will not be deallocated until all pending Blocks have finished.
 *
 * @param	label
 * A string label to attach to the queue.
 * The string is NOT copied and must remain valid for the lifetime
 * of the queue.
 * This parameter is optional and may be NULL.
 *
 * @param	attr
 * A queue attribute structure created by dispatch_queue_attr_create().
 *
 * @result
 * The newly created dispatch queue.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_NA)
DISPATCH_PUBLIC_API DISPATCH_MALLOC DISPATCH_WARN_RESULT
dispatch_queue_t
dispatch_queue_create(const char *label, dispatch_queue_attr_t attr);

/*!
 * @function	dispatch_queue_retain
 *
 * @abstract
 * Increases the reference count of a dispatch queue.
 *
 * @discussion
 * Calls to dispatch_queue_retain() must be balanced with
 * calls to dispatch_queue_release().
 *
 * @param queue
 * The queue to retain.
 * The result of passing NULL in this parameter is undefined.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_NA)
DISPATCH_PUBLIC_API DISPATCH_NONNULL_ALL
void
dispatch_queue_retain(dispatch_queue_t queue);

/*!
 * @function	dispatch_queue_release
 *
 * @abstract
 * Decreases the reference count of a dispatch queue.
 *
 * @discussion
 * A dispatch queue will be deallocated once all references
 * to it have been released (i.e. the reference count reaches
 * zero).
 *
 * @param queue
 * The queue to release.
 * The result of passing NULL in this parameter is undefined.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_NA)
DISPATCH_PUBLIC_API DISPATCH_NONNULL_ALL
void
dispatch_queue_release(dispatch_queue_t queue);

/*!
 * @function	dispatch_queue_get_label
 *
 * @abstract
 * Returns the label of the queue that was specified when the
 * queue was created.
 *
 * @param	queue
 * The result of passing NULL in this parameter is undefined.
 *
 * @result
 * The label of the queue. The result may be NULL.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_NA)
DISPATCH_PUBLIC_API DISPATCH_NONNULL_ALL DISPATCH_PURE DISPATCH_WARN_RESULT
const char *
dispatch_queue_get_label(dispatch_queue_t queue);

/*!
 * @function	dispatch_queue_get_context
 *
 * @abstract
 * Returns the application defined context of the queue.
 *
 * @param	queue
 * The result of passing NULL in this parameter is undefined.
 *
 * @result
 * The context of the queue; may be NULL.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_NA)
DISPATCH_PUBLIC_API DISPATCH_NONNULL_ALL DISPATCH_PURE DISPATCH_WARN_RESULT
void *
dispatch_queue_get_context(dispatch_queue_t queue);

/*!
 * @function	dispatch_queue_set_context
 *
 * @abstract
 * Associates an application defined context with the queue.
 *
 * @param	queue
 * The result of passing NULL in this parameter is undefined.
 *
 * @param	context
 * The new application defined context for the queue. This may be NULL.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_NA)
DISPATCH_PUBLIC_API DISPATCH_NONNULL1
void
dispatch_queue_set_context(dispatch_queue_t queue, void *context);

/*!
 * @function	dispatch_queue_suspend
 *
 * @abstract
 * Suspends the invocation of Blocks on a dispatch queue.
 *
 * @discussion
 * A suspended queue will not invoke any Blocks submitted to it.
 * Suspension of a queue will occur after the currently executing
 * Block (if any) finishes.
 *
 * Calls to dispatch_queue_suspend() must be balanced with calls
 * to dispatch_queue_resume().
 *
 * @param	queue
 * The queue to be suspended.
 * The result of passing NULL in this parameter is undefined.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_NA)
DISPATCH_PUBLIC_API DISPATCH_NONNULL_ALL
void
dispatch_queue_suspend(dispatch_queue_t queue);

/*!
 * @function	dispatch_queue_resume
 *
 * @abstract
 * Resumes the invocation of Blocks on a dispatch queue.
 *
 * @param	queue
 * The queue to be resumed.
 * The result of passing NULL in this parameter is undefined.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_NA)
DISPATCH_PUBLIC_API DISPATCH_NONNULL_ALL
void
dispatch_queue_resume(dispatch_queue_t queue);

/*!
 * @function	dispatch_queue_get_suspend_count
 *
 * @abstract
 * Returns the current suspension status of a queue (For Debugging Only).
 *
 * @discussion
 * Inspecting the suspension status of a queue may be subject to a
 * "time of check, time of use" race condition.  As a result, this
 * value should only be used for debugging.
 *
 * @param	queue
 * The queue to inspect.
 * The result of passing NULL in this parameter is undefined.
 *
 * @result
 * Returns the total number of suspensions.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_NA)
DISPATCH_PUBLIC_API DISPATCH_NONNULL_ALL DISPATCH_WARN_RESULT
size_t
dispatch_queue_get_suspend_count(dispatch_queue_t queue);

/*!
 * @function	dispatch_queue_attr_create
 *
 * @abstract
 * Creates a new dispatch queue attribute structure.  These attributes may be
 * provided at creation time to modify the default behavior of the queue.
 *
 * @discussion
 * The values present in this structure are copied to newly created queues.
 * The same attribute structure may be provided to multiple calls to
 * dispatch_queue_create() but only the values in the structure at the time the
 * call is made will be used.
 *
 * @result
 * The new dispatch queue attribute structure, initialized to default values.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_NA)
DISPATCH_PUBLIC_API DISPATCH_MALLOC DISPATCH_WARN_RESULT
dispatch_queue_attr_t
dispatch_queue_attr_create(void);

/*!
 * @function	dispatch_queue_attr_release
 *
 * @abstract
 * Releases a dispatch queue attribute structure and frees all memory
 * associated with it.
 *
 * @discussion
 * This operation has no effect on any currently running queues.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_NA)
DISPATCH_PUBLIC_API DISPATCH_NONNULL_ALL
void
dispatch_queue_attr_release(dispatch_queue_attr_t attr);

/*!
 * @enum
 * @const DISPATCH_QUEUE_PRIORITY_HIGH
 * Items dispatched to the queue will run at high priority,
 * i.e. the queue will be scheduled for execution before
 * any default priority or low priority queue.
 *
 * @const DISPATCH_QUEUE_PRIORITY_DEFAULT
 * Items dispatched to the queue will run at the default
 * priority, i.e. the queue will be scheduled for execution
 * after all high priority queues have been scheduled, but
 * before any low priority queues have been scheduled.
 *
 * @const DISPATCH_QUEUE_PRIORITY_LOW
 * Items dispatched to the queue will run at low priority,
 * i.e. the queue will be scheduled for execution after all
 * default priority and high priority queues have been
 * scheduled.
 */
enum {
	DISPATCH_QUEUE_PRIORITY_HIGH = 1,
	DISPATCH_QUEUE_PRIORITY_DEFAULT = 0,
	DISPATCH_QUEUE_PRIORITY_LOW = -1,
};

/*!
 * @function	dispatch_queue_attr_set_priority
 *
 * @abstract
 * Set the priority level for a dispatch queue.
 *
 * @discussion
 * Priority levels may be:
 * - DISPATCH_QUEUE_PRIORITY_HIGH
 * - DISPATCH_QUEUE_PRIORITY_DEFAULT
 * - DISPATCH_QUEUE_PRIORITY_LOW
 * Queues set to high priority will be processed
 * before queues set to default priority or low priority.
 * Queues set to low priority will be processed only if all
 * high priority and default priority queues are empty.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_NA)
DISPATCH_PUBLIC_API DISPATCH_NONNULL1
void
dispatch_queue_attr_set_priority(dispatch_queue_attr_t attr,
	int priority);

/*!
 * @function	dispatch_main
 *
 * @abstract
 * Applications must call this function in order to process Blocks
 * submitted to the main queue, unless a CFRunLoop is used on the
 * main thread.
 *
 * @discussion
 * This function "parks" the main thread in libdispatch and provides an
 * opportunity for Blocks submitted to the main queue to be invoked.
 *
 * Applications that call NSApplicationMain() or CFRunLoopRun() on the
 * main thread do not need to call dispatch_main().
 */
__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_NA)
DISPATCH_PUBLIC_API
void
dispatch_main(void);

#endif
